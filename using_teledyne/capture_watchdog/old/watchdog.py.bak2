import argparse
import atexit
import json
import time
import ast
import os
import sys
import pika
import psutil
import shutil
import logger
import asyncio
import pyinotify
import threading
import multiprocessing
from fshandler import FsEventHandler
from rpc_client import UOControllerRpcClient

PROCNAME = "watchdog.py"
logger = logger.logger(tofile=True)

### ---
current_path = os.path.split(os.path.abspath(os.path.realpath(sys.argv[0])))[0]
parser = argparse.ArgumentParser(description='WatchDog -- sidekick to the cuic capture'+ \
                                 '(currently only supports teledyne cameras)')
parser.add_argument('--loc', metavar='L', type=str, nargs='+', dest='location', required=True,
                    help='Location where the camera is running. Queue name will be generated from this')
args = parser.parse_args()
RPC_VHOST = "/vis"
RPC_QUEUE_NAME = args.location[0] + "_watchdog"
RPC_SERVER = os.getenv("rpc_server")
RPC_PORT = os.getenv("rpc_port")
RPC_USER = os.getenv("rpc_user")
RPC_PASS = os.getenv("rpc_pass")
IMG_DIR = os.path.join(os.getenv("mtc_vis_dir"), args.location[0], "live")

known_vis_queues = {
    "1mtcNorth": {"cam": "1mtcNorth", "watchdog": "1mtcNorth_watchdog"},
    "1mtcSouth": {"cam": "1mtcSouth", "watchdog": "1mtcSouth_watchdog"},
    "370Roof"  : {"cam": "370Roof", "watchdog": "370Roof_watchdog"},
    "test"     : {"cam": "test", "watchdog": "test_watchdog"},
}

mask = pyinotify.IN_DELETE | pyinotify.IN_CREATE | pyinotify.IN_MOVED_TO | pyinotify.IN_CLOSE_WRITE # watched events

def monitor_fs(directory, cam_commands, pt_locations, lock):
    """
    Monitoring file system for new files every `interval`.
    If no new files are created between x and x+1.5*(`interval`)
    then a callback request will be made
    Parameters
    ----------
    directory: str
        absolute path to the directory to be monitored
    """
    wm = pyinotify.WatchManager()
    loop = asyncio.get_event_loop()
    event_handler = FsEventHandler(cam_commands, pt_locations, lock)
    notifier = pyinotify.AsyncioNotifier(wm, loop,
                                         default_proc_fun=event_handler)
    wm.add_watch(directory, mask)
    loop.run_forever()
    notifier.stop()

def _cam_status(loc):
    """
    Function to obtain the status from the camera
    and the birger adapter
    Parameters
        ----------
    loc: str
    location of the camera to fetch the information of
    """
    cam_status_cmd = {
        "interval": 0,
        "focus": -99,
        "location": loc,
        "status": True,
        "aperture": -99,
        "exposure": -99,
        "stop": False,
        "capture": 0,
        "kill": ""
    }
    vis_cam_rpc_client = UOControllerRpcClient(vhost=RPC_VHOST,
                                               queue_name=known_vis_queues[cam_status_cmd["location"]]["cam"])
    cam_response = vis_cam_rpc_client.call(json.dumps(cam_status_cmd))
    status_message = None
    try:
        status_message = ast.literal_eval(cam_response.strip("b'"))
    except Exception as ex:
        status_messages = "Error getting camera status: "+str(ex)
        logger.warning("Error getting camera status: "+str(ex))
        # Cannot communicate with the camera, restart it?
        #cam_response = self.restart_camera(cam_status_cmd, self.lock)
    #status_message = ast.literal_eval(cam_response.strip("b'"))
    # hacky way to clear the object
    vis_cam_rpc_client = None
    del vis_cam_rpc_client
    return status_message

def status(cam_location):
    try:
        # Obtain the status to write to file as metadata
        cam_status = _cam_status(cam_location)
        #lens_status = self._lens_status(birger)
        #_status = {"camera": cam_status, "lens": lens_status}
        with open(os.path.join(current_path, "current_status.meta"), "r") as fh:
            _status = json.load(fh)
        _status.update({"camera": cam_status})
        return _status
    except Exception as ex:
        logger.critical("Error obtaining status: "+str(ex))


def on_rpc_request(ch, method, props, body):
    """
    Blocking Function for handling the incoming data
    Refer "http://pika.readthedocs.io/en/0.11.2/modules/adapters/blocking.html"
    """
    current_path = os.path.split(os.path.abspath(os.path.realpath(sys.argv[0])))[0]
    command_dict = json.loads(body.decode("utf-8"))
    if command_dict["status"] == True:
        response = status(command_dict["location"])
    else:
        with open(os.path.join(current_path, "last_command.cmd"), "w") as fh:
            json.dump(command_dict, fh)
        pt_locations.update({"locations": command_dict["pt_locs"]})
        command_dict.pop("pt_locs", None)
        cam_commands.update(command_dict)
        response = "OK"
    """
    # If the camera is on a pan and tilt mechanism
    if command_dict.get("pt_locs", None):
        if command_dict["pt_locs"][0][0] == -999999:
            # we should not pass the commands to ptcontroller
            cam_commands.update(command_dict)
            reponse = "OK"
            #response = _process_commands(command_dict, cam_commands)
        else:
            pt_locations.update({"locations": command_dict["pt_locs"]})
            command_dict.pop("pt_locs", None)
            cam_commands.update(command_dict)
            response = "OK"
    else:
        # If the camera is not on a pan and tilt mechanism?
        response = _process_commands(command_dict, cam_commands)
    """
    logger.info("Correlation id: " + str(props.correlation_id))
    #logger.info("cam commands: "+str(cam_commands))
    
    ch.basic_publish(exchange='',
                     routing_key=props.reply_to,
                     properties=pika.BasicProperties(correlation_id=props.correlation_id),
                     body=str(response))
    ch.basic_ack(delivery_tag=method.delivery_tag)

def _quit():
    sys.exit(2)
        
if __name__ == "__main__":
    for proc in psutil.process_iter():
        if PROCNAME in proc.name():
            if "watchdog.py" in [x for y in list(map(lambda x: x.split('/'), proc.cmdline())) for x in y]:
                proc.terminate()

    mp_manager = multiprocessing.Manager()
    cam_commands = mp_manager.dict()
    pt_locations = mp_manager.dict()
    lock = mp_manager.Lock()
    # Start FS monitoring
    logger.info("Starting fs monitoring")
    fs_process = multiprocessing.Process(target=monitor_fs, args=(IMG_DIR, cam_commands, pt_locations, lock))
    fs_process.daemon=True
    fs_process.start()
    # Start pan and tilt controller process
    #logger.info("Starting pt controller")
    #pt_process = multiprocessing.Process(target=pt_controller, args=(None, pt_locations, cam_commands, lock))
    #pt_process.daemon = True
    #pt_process.start()
    logger.info("Opening Connection with RabbitMQ")
    credentials = pika.PlainCredentials(os.getenv("rpc_user"), os.getenv("rpc_pass"))
    connection = pika.BlockingConnection(
        pika.ConnectionParameters(os.getenv("rpc_server"), os.getenv("rpc_port"),
                                  RPC_VHOST, credentials))
    channel = connection.channel()
    channel.queue_declare(queue=RPC_QUEUE_NAME)

    try:
        # replay previous command
        #_replay_prev_command(cam_commands, lock)
        channel.basic_qos(prefetch_count=1)
        channel.basic_consume(on_rpc_request, queue=RPC_QUEUE_NAME)
        logger.info("Listening for RPC messages")
        channel.start_consuming()
    except KeyboardInterrupt as ki:
        print()
        logger.info("Exiting now")
    except Exception as ex:
        logger.critical("Critical Exception in main: "+str(ex))
